<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <title>Binary Prime Engine</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #0f2027, #203a43, #2c5364);
      color: #fff;
    }
    header {
      background-color: #111;
      padding: 20px;
      text-align: center;
      font-size: 2em;
      font-weight: bold;
      color: #00d8ff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    .container {
      padding: 30px;
      max-width: 900px;
      margin: auto;
      background-color: #1e1e2f;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 216, 255, 0.2);
    }
    .menu {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 30px;
    }
    .menu button {
      background: #00d8ff;
      color: #000;
      padding: 15px;
      font-size: 1.1em;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .menu button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 15px rgba(0,216,255,0.4);
    }
    input[type="text"], input[type="number"] {
      width: 250px;
      padding: 12px;
      font-size: 1.2em;
      margin-bottom: 20px;
      border-radius: 10px;
      border: none;
      text-align: center;
    }
    .result {
      margin-top: 25px;
      padding: 15px;
      background-color: #292942;
      border-radius: 10px;
      font-size: 1.1em;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <header>Binary Prime Engine</header>
  <p style="text-align:center; margin: 18px 0 0 0; font-size:1.15em; color:#00d8ff;">
    Binary Prime Engine computes and visualizes "prime" numbers using modular filters and binary patterns.<br>
    All results are based on your custom engine, not classical primality.<br>
    Ora supporta numeri enormi grazie a <b>BigInt</b>!
  </p>
  <div class="container">
    <input type="text" id="inputNumber" placeholder="Enter a (big) integer">
    <div class="menu">
      <button onclick="checkPrime()">Check if Prime</button>
      <button onclick="calculateGap()">Immediate Gap dₙ</button>
      <button onclick="nextPrime()">Next Prime</button>
      <button onclick="primeIndex()">Prime Sequence Index</button>
      <button onclick="compositeIndex()">Composite Sequence Index</button>
      <button onclick="factorize()">Prime Factorization</button>
      <button onclick="findTwins()">Twin Primes</button>
      <button onclick="findDoubleTwins()">Double Twins</button>
      <button onclick="showBinaryPrimes()">Binary Primes</button>
      <button onclick="generatePrimes()">Generate Interval</button>
      <button onclick="drawInteractiveSpiral3D()">Interactive 3D Spiral</button>
      <div style="margin: 20px 0 10px 0; text-align:center;">
        <input type="number" id="spiral3DFrom" placeholder="3D From (≥2)" min="2" value="2">
        <input type="number" id="spiral3DTo" placeholder="3D To (≤10000)" min="2" value="100">
      </div>
    </div>
    <div class="result" id="result"></div>
    <div id="primeSpiral3D" style="width: 100%; height: 600px; margin-top:30px;"></div>
  </div>

  <script>
const primeRules = {
  primorial: 30030n, // 2*3*5*7*11*13
  moduloDivisors: [2n, 3n, 5n, 7n, 11n, 13n],
  binaryPatterns: [
    '10', '11', '100', '101', '111', '1001', '1101', '1111', '1011', '11011', '11101', '10101'
  ]
};
const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n];

function isPrimeBit(n) {
  if (n < 2n) return false;
  if (smallPrimes.includes(n)) return true;
  const Pk = primeRules.primorial;
  const r = n % Pk;
  for (let d of primeRules.moduloDivisors) {
    if (r % d === 0n) return false;
  }
  const binStr = n.toString(2);
  let binOk = false;
  for (let b of primeRules.binaryPatterns) {
    if (binStr.includes(b)) {
      binOk = true;
      break;
    }
  }
  if (!binOk) return false;
  if ((binStr.match(/1/g) || []).length < 3) return false;
  return true;
}

function checkPrime() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  const n = BigInt(val);
  if (n < 2n) {
    r.innerText = "Please enter an integer ≥ 2.";
    return;
  }
  if (smallPrimes.includes(n)) {
    r.innerText = `${n} is a prime number (by engine) ✅`;
    return;
  }
  r.innerText = isPrimeBit(n) ? `${n} is a prime number (by engine) ✅` : `${n} is not prime (by engine) ❌`;
}

function calculateGap() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let k = BigInt(val);
  if (k < 2n) {
    r.innerText = "Please enter an integer ≥ 2.";
    return;
  }
  let next = k + 1n;
  while (!smallPrimes.includes(next) && !isPrimeBit(next)) next++;
  const gap = next - k;
  r.innerText = `Immediate gap dₙ after ${k}: dₙ = ${gap}\nNext prime: next_prime(${k}) = ${next}`;
}

function nextPrime() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 1n) {
    r.innerText = "Please enter an integer ≥ 1.";
    return;
  }
  let next = n + 1n;
  while (!smallPrimes.includes(next) && !isPrimeBit(next)) next++;
  r.innerText = `next_prime(${n}) = ${next}\nThe next "prime" after ${n} (by engine) is ${next}.`;
}

function primeIndex() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 2n) {
    r.innerText = "Please enter an integer ≥ 2.";
    return;
  }
  for (let i = 0; i < smallPrimes.length; i++) {
    if (n === smallPrimes[i]) {
      return r.innerText = `n = π(${n}) = ${i + 1}\n${n} is the prime number n=${i + 1} in the engine sequence.`;
    }
  }
  if (!isPrimeBit(n)) return r.innerText = `${n} is not a prime number according to the engine.`;
  let count = 0n;
  for (let p of smallPrimes) {
    if (p < n) count++;
  }
  for (let i = BigInt(Math.max(...smallPrimes.map(Number))) + 1n; i < n; i++) {
    if (isPrimeBit(i)) count++;
  }
  r.innerText = `n = π(${n}) = ${count + 1n}\n${n} is the prime number n=${count + 1n} in the engine sequence.`;
}

function compositeIndex() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 4n) {
    r.innerText = "Please enter a valid composite number (≥ 4).";
    return;
  }
  if (smallPrimes.includes(n) || isPrimeBit(n)) return r.innerText = `${n} is a prime number (by engine), not composite.`;
  let count = 0n;
  for (let i = 4n; i <= n; i++) {
    if (!smallPrimes.includes(i) && !isPrimeBit(i)) count++;
  }
  r.innerText = `${n} is the composite number c=${count} in the engine sequence of composites.`;
}

function factorize() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 2n) return r.innerText = "Invalid number.";
  const factors = [];
  let d = 2n;
  while (n > 1n) {
    while (n % d === 0n) {
      factors.push(d.toString());
      n /= d;
    }
    d++;
    if (d * d > n && n > 1n) {
      factors.push(n.toString());
      break;
    }
  }
  r.innerText = `Prime factors: ` + factors.join(" × ");
}

function findTwins() {
  const da = BigInt(prompt("From (inclusive):"));
  const a = BigInt(prompt("To (inclusive):"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) return r.innerText = "Invalid interval.";
  if (a - da > 10000n) return r.innerText = "Interval too large (max 10,000 numbers).";
  const twins = [];
  let allPrimes = [];
  for (let p of smallPrimes) {
    if (p >= da && p <= a) allPrimes.push(p);
  }
  for (let n = BigInt(Math.max(...smallPrimes.map(Number))) + 1n; n <= a; n++) {
    if (isPrimeBit(n)) allPrimes.push(n);
  }
  allPrimes.sort((a, b) => (a < b ? -1 : 1));
  for (let i = 0; i < allPrimes.length - 1; i++) {
    if (allPrimes[i + 1] - allPrimes[i] === 2n) twins.push(`(${allPrimes[i]}, ${allPrimes[i + 1]})`);
  }
  r.innerText = `Twin primes (by engine) between ${da} and ${a}:\n` + (twins.length ? twins.join(", ") : "No pairs found.");
}

function findDoubleTwins() {
  const da = BigInt(prompt("From (inclusive):", "2"));
  const a = BigInt(prompt("To (inclusive):", "1000"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) return r.innerText = "Invalid interval.";
  if (a - da > 10000n) return r.innerText = "Interval too large (max 10,000 numbers).";
  const primes = [];
  for (let p of smallPrimes) {
    if (p >= da && p <= a) primes.push(p);
  }
  for (let n = BigInt(Math.max(...smallPrimes.map(Number))) + 1n; n <= a; n++) {
    if (isPrimeBit(n)) primes.push(n);
  }
  primes.sort((a, b) => (a < b ? -1 : 1));
  const groups = [];
  for (let i = 0; i < primes.length - 1; i++) {
    if (primes[i + 1] - primes[i] === 4n) {
      if (i > 0 && primes[i] - primes[i - 1] === 2n) {
        groups.push(`(${primes[i - 1]}, ${primes[i]}, ${primes[i + 1]})`);
      } else {
        groups.push(`(${primes[i]}, ${primes[i + 1]})`);
      }
    }
  }
  r.innerText = `Double twin groups (distance 4, by engine) between ${da} and ${a}:\n` +
    (groups.length ? groups.join(", ") : "No group found.");
}

function showBinaryPrimes() {
  const da = BigInt(prompt("From (inclusive):", "2"));
  const a = BigInt(prompt("To (inclusive):", "100"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) {
    r.innerText = "Invalid interval.";
    return;
  }
  if (a - da > 10000n) {
    r.innerText = "Interval too large (max 10,000 numbers).";
    return;
  }
  const B = primeRules.binaryPatterns;
  let out = `Binary primes (by engine) between ${da} and ${a}:\n\n`;
  for (let p of smallPrimes) {
    if (p >= da && p <= a) {
      const binStr = p.toString(2);
      const patterns = B.filter(b => binStr.includes(b));
      out += `${p}: ${binStr}   [pattern: ${patterns.join(", ")}]\n`;
    }
  }
  for (let n = BigInt(Math.max(...smallPrimes.map(Number))) + 1n; n <= a; n++) {
    if (isPrimeBit(n)) {
      const binStr = n.toString(2);
      const patterns = B.filter(b => binStr.includes(b));
      out += `${n}: ${binStr}   [pattern: ${patterns.join(", ")}]\n`;
    }
  }
  r.innerText = out;
}

function generatePrimes() {
  const da = BigInt(prompt("From (inclusive):"));
  const a = BigInt(prompt("To (inclusive):"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) return r.innerText = "Invalid interval.";
  if (a - da > 10000n) return r.innerText = "Interval too large (max 10,000 numbers).";
  const list = [];
  for (let p of smallPrimes) {
    if (p >= da && p <= a) list.push(p);
  }
  for (let i = BigInt(Math.max(...smallPrimes.map(Number))) + 1n; i <= a; i++) {
    if (isPrimeBit(i)) list.push(i);
  }
  r.innerText = `Primes (by engine) between ${da} and ${a}:\n` + list.join(", ");
}

function drawInteractiveSpiral3D() {
  const from = parseInt(document.getElementById("spiral3DFrom").value) || 2;
  const to = parseInt(document.getElementById("spiral3DTo").value) || 100;
  const primes = [];
  for (let p of smallPrimes) {
    if (p >= BigInt(from) && p <= BigInt(to)) primes.push(Number(p));
  }
  for (let n = BigInt(Math.max(...smallPrimes.map(Number))) + 1n; n <= BigInt(to); n++) {
    if (isPrimeBit(n)) primes.push(Number(n));
  }

  const theta = primes.map((p, i) => i * 0.4);
  const r = primes.map(p => p * 80);
  const x = r.map((ri, i) => ri * Math.cos(theta[i]));
  const y = r.map((ri, i) => ri * Math.sin(theta[i]));
  const z = primes;

  const xGap = Array(primes.length).fill(0);
  const yGap = Array(primes.length).fill(0);
  const zGap = primes;

  const traceSpiral = {
    x: x,
    y: y,
    z: z,
    mode: 'lines+markers',
    type: 'scatter3d',
    name: 'Prime Spiral',
    line: { color: 'blue', width: 3 },
    marker: { size: 4, color: 'blue' }
  };

  const traceGap = {
    x: xGap,
    y: yGap,
    z: zGap,
    mode: 'markers+lines',
    type: 'scatter3d',
    name: 'Gap Spiral',
    marker: { size: 4, color: 'purple' },
    line: { color: 'purple', width: 3 }
  };

  const layout = {
    title: '3D Comparison: Prime Spiral & Gap Spiral (by engine)',
    scene: {
      xaxis: { title: '', showgrid: true },
      yaxis: { title: '', showgrid: true },
      zaxis: { title: '', showgrid: true }
    },
    legend: { x: 0.8, y: 0.9 }
  };

  Plotly.newPlot('primeSpiral3D', [traceSpiral, traceGap], layout, {responsive: true});
}
  </script>
</body>
</html>