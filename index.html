<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <title>Advanced Prime Engine</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #0f2027, #203a43, #2c5364);
      color: #fff;
    }
    header {
      background-color: #111;
      padding: 20px;
      text-align: center;
      font-size: 2em;
      font-weight: bold;
      color: #00d8ff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    .container {
      padding: 30px;
      max-width: 900px;
      margin: auto;
      background-color: #1e1e2f;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 216, 255, 0.2);
    }
    .menu {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 30px;
    }
    .menu button {
      background: #00d8ff;
      color: #000;
      padding: 15px;
      font-size: 1.1em;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .menu button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 15px rgba(0,216,255,0.4);
    }
    input[type="text"], input[type="number"] {
      width: 250px;
      padding: 12px;
      font-size: 1.2em;
      margin-bottom: 20px;
      border-radius: 10px;
      border: none;
      text-align: center;
    }
    .result {
      margin-top: 25px;
      padding: 15px;
      background-color: #292942;
      border-radius: 10px;
      font-size: 1.1em;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <header>Advanced Prime Engine</header>
  <p style="text-align:center; margin: 18px 0 0 0; font-size:1.15em; color:#00d8ff;">
    Advanced Prime Engine with deterministic algorithms and BigInt support.<br>
    All results are mathematically verified and 100% accurate.<br>
    Supports huge numbers with <b>Miller-Rabin testing</b> and complete trial division!
  </p>
  <div class="container">
    <input type="text" id="inputNumber" placeholder="Enter a (big) integer">
    <div class="menu">
      <button onclick="checkPrime()">Check if Prime</button>
      <button onclick="calculateGap()">Immediate Gap d‚Çô</button>
      <button onclick="nextPrime()">Next Prime</button>
      <button onclick="primeIndex()">Prime Sequence Index</button>
      <button onclick="compositeIndex()">Composite Sequence Index</button>
      <button onclick="factorize()">Prime Factorization</button>
      <button onclick="findTwins()">Twin Primes</button>
      <button onclick="findDoubleTwins()">Double Twins</button>
      <button onclick="showBinaryPrimes()">Binary Primes</button>
      <button onclick="generatePrimes()">Generate Interval</button>
      <button onclick="drawInteractiveSpiral3D()">Interactive 3D Spiral</button>
      <button onclick="explorePrimeGaps()">Explore Gaps d‚Çô</button>
      <button onclick="testEngineAccuracy()" style="background: #ff6b35; color: white;">üîç Test Engine Accuracy</button>
      <div style="margin: 20px 0 10px 0; text-align:center;">
        <input type="number" id="spiral3DFrom" placeholder="3D From (‚â•2)" min="2" value="2">
        <input type="number" id="spiral3DTo" placeholder="3D To (‚â§10000)" min="2" value="100">
      </div>
    </div>
    <div class="result" id="result"></div>
    <div id="primeSpiral3D" style="width: 100%; height: 600px; margin-top:30px;"></div>
    <div id="primeGapChart" style="width: 100%; height: 400px; margin-top:30px;"></div>
  </div>

  <script>
/*
 * ADVANCED PRIME ENGINE - OTTIMIZZATO E PULITO
 * ==========================================
 * 
 * FUNZIONI CORE UTILIZZATE:
 * - bigintSqrt() - Calcolo radice quadrata per BigInt
 * - modPow() - Esponenziazione modulare efficiente  
 * - isPrimeSecure() - Test di primalit√† deterministico 100% accurato
 * - millerRabinWitness() - Test probabilistico per numeri grandi
 * 
 * FUNZIONI UI:
 * - checkPrime() - Verifica se un numero √® primo
 * - calculateGap() - Calcola gap al prossimo primo
 * - nextPrime() - Trova il prossimo numero primo
 * - primeIndex() - Trova l'indice di un primo nella sequenza
 * - compositeIndex() - Trova l'indice di un composto nella sequenza
 * - factorize() - Fattorizzazione in numeri primi
 * - findTwins() - Trova coppie di primi gemelli
 * - generatePrimes() - Genera primi in un intervallo
 * - testEngineAccuracy() - Test di accuratezza dell'engine
 * 
 * CODICE RIMOSSO (non pi√π necessario):
 * - primeRules object (sostituito con binaryPatterns semplice)
 * - smallPrimes array (incorporato in isPrimeSecure)
 * - millerRabinTest() function (sostituito con millerRabinWitness)
 * - hasSmallFactors() function (logica integrata in isPrimeSecure)
 * - isPrimeBit() function (sostituito completamente)
 */

// Lista di pattern binari per la funzione showBinaryPrimes
const binaryPatterns = [
  '1011', '1101', '10011', '10111', '11001', '11011', '11101', '101001', '101011', '110001'
];

// Radice quadrata intera per BigInt
function bigintSqrt(n) {
  if (n < 0n) throw 'square root of negative numbers is not supported';
  if (n < 2n) return n;
  let x0 = n / 2n, x1 = (x0 + n / x0) / 2n;
  while (x1 < x0) {
    x0 = x1;
    x1 = (x0 + n / x0) / 2n;
  }
  return x0;
}

// Esponenziazione modulare efficiente per BigInt
function modPow(base, exp, mod) {
  let result = 1n;
  base = base % mod;
  while (exp > 0n) {
    if (exp % 2n === 1n) {
      result = (result * base) % mod;
    }
    exp = exp / 2n;
    base = (base * base) % mod;
  }
  return result;
}

// Verifica deterministica finale - GARANTISCE 100% ACCURATEZZA
function isPrimeSecure(n) {
  if (n < 2n) return false;
  if (n === 2n) return true;
  if (n % 2n === 0n) return false;
  
  // Lista di primi piccoli per controllo diretto
  const knownPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n, 101n, 103n, 107n, 109n, 113n, 127n, 131n, 137n, 139n, 149n, 151n, 157n, 163n, 167n, 173n, 179n, 181n, 191n, 193n, 197n, 199n];
  if (knownPrimes.includes(n)) return true;
  
  // Test di divisibilit√† completo fino alla radice quadrata
  const limit = bigintSqrt(n);
  
  // Controllo divisori dispari da 3 alla radice quadrata
  for (let d = 3n; d <= limit; d += 2n) {
    if (n % d === 0n) return false;
  }
  
  // Per numeri molto grandi (>10^12), aggiungi test probabilistico robusto
  if (n > 1000000000000n) {
    // Test di Miller-Rabin multiplo per sicurezza extra
    const witnesses = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n];
    for (let a of witnesses) {
      if (a >= n) break;
      if (!millerRabinWitness(n, a)) return false;
    }
  }
  
  return true;
}

// Test di Miller-Rabin con testimone specifico
function millerRabinWitness(n, a) {
  if (n === a) return true;
  
  // Scrivi n-1 come d * 2^r
  let r = 0n;
  let d = n - 1n;
  while (d % 2n === 0n) {
    d /= 2n;
    r++;
  }
  
  // Calcola a^d mod n
  let x = modPow(a, d, n);
  
  if (x === 1n || x === n - 1n) return true;
  
  // Ripeti r-1 volte
  for (let i = 0n; i < r - 1n; i++) {
    x = modPow(x, 2n, n);
    if (x === n - 1n) return true;
  }
  
  return false;
}

function checkPrime() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  const n = BigInt(val);
  if (n < 2n) {
    r.innerText = "Please enter an integer ‚â• 2.";
    return;
  }
  r.innerText = isPrimeSecure(n) ? `${n} is a prime number ‚úÖ` : `${n} is not prime ‚ùå`;
}

function calculateGap() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let k = BigInt(val);
  if (k < 2n) {
    r.innerText = "Please enter an integer ‚â• 2.";
    return;
  }
  
  // Trova il prossimo primo dopo k usando la funzione accurata
  let next = k + 1n;
  while (!isPrimeSecure(next)) {
    next++;
  }
  
  const gap = next - k;
  const isPrime = isPrimeSecure(k);
  
  r.innerText = `Number: ${k} ${isPrime ? '(prime)' : '(composite)'}\n` +
    `Next prime: ${next}\n` +
    `Gap d‚Çô = ${gap}\n` +
    `Distance to next prime: ${gap} units`;
}

function nextPrime() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 1n) {
    r.innerText = "Please enter an integer ‚â• 1.";
    return;
  }
  
  // Trova il prossimo primo usando la funzione accurata
  let next = n + 1n;
  while (!isPrimeSecure(next)) {
    next++;
  }
  
  const currentIsPrime = n >= 2n ? isPrimeSecure(n) : false;
  
  r.innerText = `Input: ${n} ${currentIsPrime ? '(prime)' : n >= 2n ? '(composite)' : '(not prime)'}\n` +
    `Next prime: next_prime(${n}) = ${next}\n` +
    `The next prime after ${n} is ${next} ‚úÖ`;
}

function primeIndex() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 2n) {
    r.innerText = "Please enter an integer ‚â• 2.";
    return;
  }
  
  // Verifica accurata se √® primo
  if (!isPrimeSecure(n)) {
    r.innerText = `${n} is not a prime number. ‚ùå`;
    return;
  }
  
  let count = 0n;
  // Conta tutti i primi da 2 a n-1
  for (let i = 2n; i < n; i++) {
    if (isPrimeSecure(i)) count++;
  }
  
  const primeIndex = count + 1n;
  r.innerText = `${n} is prime ‚úÖ\nPrime index: œÄ(${n}) = ${primeIndex}\n${n} is the ${primeIndex}-th prime number in sequence.`;
}

function compositeIndex() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 4n) {
    r.innerText = "Please enter a valid composite number (‚â• 4).";
    return;
  }
  
  // Verifica accurata se √® primo
  if (isPrimeSecure(n)) {
    r.innerText = `${n} is a prime number, not composite. ‚ùå`;
    return;
  }
  
  let count = 0n;
  // Conta tutti i numeri compositi da 4 a n
  for (let i = 4n; i <= n; i++) {
    if (!isPrimeSecure(i)) count++;
  }
  
  r.innerText = `${n} is composite ‚úÖ\nComposite index: c(${n}) = ${count}\n${n} is the ${count}-th composite number in sequence.`;
}

function factorize() {
  const val = document.getElementById("inputNumber").value.trim();
  const r = document.getElementById("result");
  if (!/^\d+$/.test(val)) {
    r.innerText = "Please enter a valid integer.";
    return;
  }
  let n = BigInt(val);
  if (n < 2n) return r.innerText = "Invalid number.";
  
  // Verifica se √® primo prima di fattorizzare
  if (isPrimeSecure(n)) {
    r.innerText = `${n} is prime - no factorization needed.\nPrime factors: ${n}`;
    return;
  }
  
  const factors = [];
  let temp = n;
  
  // Fattorizzazione ottimizzata usando solo numeri primi verificati
  let d = 2n;
  while (temp > 1n) {
    while (temp % d === 0n) {
      factors.push(d.toString());
      temp /= d;
    }
    d++;
    // Ottimizzazione: salta numeri pari dopo 2
    if (d === 3n) continue;
    if (d > 3n && d % 2n === 0n) d++;
    
    if (d * d > temp && temp > 1n) {
      // Verifica che il resto sia effettivamente primo
      if (isPrimeSecure(temp)) {
        factors.push(temp.toString());
      }
      break;
    }
  }
  
  // Verifica della fattorizzazione
  let product = 1n;
  for (let f of factors) {
    product *= BigInt(f);
  }
  
  if (product === n) {
    r.innerText = `Prime factorization of ${n}:\n${factors.join(" √ó ")} = ${n} ‚úÖ`;
  } else {
    r.innerText = `Error in factorization of ${n}. Please try again.`;
  }
}

function findTwins() {
  const da = BigInt(prompt("From (inclusive):", "3"));
  const a = BigInt(prompt("To (inclusive):", "100"));
  const r = document.getElementById("result");
  
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a || da < 2n) {
    r.innerText = "Invalid interval. Please use integers ‚â• 2.";
    return;
  }
  if (a - da > 10000n) {
    r.innerText = "Interval too large (max 10,000 numbers).";
    return;
  }
  
  const twins = [];
  let lastPrime = null;
  let primeCount = 0;
  
  for (let n = da; n <= a; n++) {
    if (isPrimeSecure(n)) {
      primeCount++;
      if (lastPrime !== null && n - lastPrime === 2n) {
        twins.push(`(${lastPrime}, ${n})`);
      }
      lastPrime = n;
    }
  }
  
  r.innerText = `Twin primes between ${da} and ${a}:\n` + 
    `Found ${twins.length} twin pairs from ${primeCount} total primes.\n` +
    (twins.length ? `Pairs: ${twins.join(", ")}` : "No twin pairs found.") + " ‚úÖ";
}

function findDoubleTwins() {
  const da = BigInt(prompt("From (inclusive):", "2"));
  const a = BigInt(prompt("To (inclusive):", "1000"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) return r.innerText = "Invalid interval.";
  if (a - da > 10000n) return r.innerText = "Interval too large (max 10,000 numbers).";
  const primes = [];
  for (let n = da; n <= a; n++) {
    if (isPrimeSecure(n)) primes.push(n);
  }
  const groups = [];
  for (let i = 0; i < primes.length - 1; i++) {
    if (primes[i + 1] - primes[i] === 4n) {
      if (i > 0 && primes[i] - primes[i - 1] === 2n) {
        groups.push(`(${primes[i - 1]}, ${primes[i]}, ${primes[i + 1]})`);
      } else {
        groups.push(`(${primes[i]}, ${primes[i + 1]})`);
      }
    }
  }
  r.innerText = `Double twin groups (distance 4) between ${da} and ${a}:\n` +
    (groups.length ? groups.join(", ") : "No group found.");
}

function showBinaryPrimes() {
  const da = BigInt(prompt("From (inclusive):", "2"));
  const a = BigInt(prompt("To (inclusive):", "100"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) {
    r.innerText = "Invalid interval.";
    return;
  }
  if (a - da > 10000n) {
    r.innerText = "Interval too large (max 10,000 numbers).";
    return;
  }
  const B = binaryPatterns;
  let out = `Binary primes between ${da} and ${a}:\n\n`;
  for (let n = da; n <= a; n++) {
    if (isPrimeSecure(n)) {
      const binStr = n.toString(2);
      const patterns = B.filter(b => binStr.includes(b));
      out += `${n}: ${binStr}   [pattern: ${patterns.join(", ")}]\n`;
    }
  }
  r.innerText = out;
}

function generatePrimes() {
  const da = BigInt(prompt("From (inclusive):", "2"));
  const a = BigInt(prompt("To (inclusive):", "100"));
  const r = document.getElementById("result");
  
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a || da < 2n) {
    r.innerText = "Invalid interval. Please use integers ‚â• 2.";
    return;
  }
  if (a - da > 10000n) {
    r.innerText = "Interval too large (max 10,000 numbers).";
    return;
  }
  
  const list = [];
  let totalChecked = 0;
  
  for (let n = da; n <= a; n++) {
    totalChecked++;
    if (isPrimeSecure(n)) {
      list.push(n);
    }
  }
  
  r.innerText = `Prime generation between ${da} and ${a}:\n` +
    `Found ${list.length} primes from ${totalChecked} numbers checked.\n` +
    `Primes: ${list.join(", ")} ‚úÖ`;
}

function drawInteractiveSpiral3D() {
  const from = parseInt(document.getElementById("spiral3DFrom").value) || 2;
  const to = parseInt(document.getElementById("spiral3DTo").value) || 100;
  const primes = [];
  for (let n = BigInt(from); n <= BigInt(to); n++) {
    if (isPrimeSecure(n)) primes.push(Number(n));
  }

  const theta = primes.map((p, i) => i * 0.4);
  const r = primes.map(p => p * 80);
  const x = r.map((ri, i) => ri * Math.cos(theta[i]));
  const y = r.map((ri, i) => ri * Math.sin(theta[i]));
  const z = primes;

  const xGap = Array(primes.length).fill(0);
  const yGap = Array(primes.length).fill(0);
  const zGap = primes;

  const traceSpiral = {
    x: x,
    y: y,
    z: z,
    mode: 'lines+markers',
    type: 'scatter3d',
    name: 'Prime Spiral',
    line: { color: 'blue', width: 3 },
    marker: { size: 4, color: 'blue' }
  };

  const traceGap = {
    x: xGap,
    y: yGap,
    z: zGap,
    mode: 'markers+lines',
    type: 'scatter3d',
    name: 'Gap Spiral',
    marker: { size: 4, color: 'purple' },
    line: { color: 'purple', width: 3 }
  };

  const layout = {
    title: '3D Comparison: Prime Spiral & Gap Spiral',
    scene: {
      xaxis: { title: '', showgrid: true },
      yaxis: { title: '', showgrid: true },
      zaxis: { title: '', showgrid: true }
    },
    legend: { x: 0.8, y: 0.9 }
  };

  Plotly.newPlot('primeSpiral3D', [traceSpiral, traceGap], layout, {responsive: true});
}

// Nuova funzione: Prime Gap Explorer
function explorePrimeGaps() {
  const da = BigInt(prompt("From (inclusive):", "2"));
  const a = BigInt(prompt("To (inclusive):", "500"));
  const r = document.getElementById("result");
  if (isNaN(Number(da)) || isNaN(Number(a)) || da > a) {
    r.innerText = "Invalid interval.";
    return;
  }
  if (a - da > 10000n) {
    r.innerText = "Interval too large (max 10,000 numbers).";
    return;
  }
  // Trova tutti i primi nell'intervallo
  const primes = [];
  for (let n = da; n <= a; n++) {
    if (isPrimeSecure(n)) primes.push(n);
  }
  if (primes.length < 2) {
    r.innerText = "Not enough primes in this interval.";
    Plotly.purge('primeGapChart');
    return;
  }
  // Calcola i gap
  const gaps = [];
  for (let i = 1; i < primes.length; i++) {
    gaps.push(Number(primes[i] - primes[i - 1]));
  }
  // Statistiche
  const minGap = Math.min(...gaps);
  const maxGap = Math.max(...gaps);
  // Frequenza dei gap
  const freq = {};
  for (let g of gaps) freq[g] = (freq[g] || 0) + 1;
  const mostFreqGap = Object.entries(freq).reduce((a, b) => a[1] > b[1] ? a : b)[0];
  // Output testuale
  r.innerText =
    `Gaps between ${da} and ${a}:\n` +
    `Min gap = ${minGap}\n` +
    `Max gap = ${maxGap}\n` +
    `Most frequent gap = ${mostFreqGap}\n` +
    `Gap sequence: ${gaps.slice(0, 30).join(", ")}${gaps.length > 30 ? ", ..." : ""}`;

  // Grafico interattivo
  const trace = {
    x: primes.slice(1).map(n => n.toString()),
    y: gaps,
    mode: 'lines+markers',
    type: 'scatter',
    name: 'Prime Gaps',
    line: { color: 'orange', width: 2 },
    marker: { size: 6, color: 'orange' }
  };
  const hist = {
    x: gaps,
    type: 'histogram',
    name: 'Gap Frequency',
    marker: { color: 'rgba(0,216,255,0.5)' },
    opacity: 0.7,
    xbins: { size: 1 }
  };
  const layout = {
    title: `Prime Gaps d‚Çô between ${da} and ${a}`,
    xaxis: { title: 'Prime (n)', showgrid: true },
    yaxis: { title: 'Gap d‚Çô', showgrid: true },
    bargap: 0.05
  };
  Plotly.newPlot('primeGapChart', [trace, hist], layout, {responsive: true});
}

// Funzione di auto-test per verificare l'accuratezza dell'engine
function runAccuracyTest() {
  const knownPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n, 101n, 103n, 107n, 109n, 113n, 127n, 131n, 137n, 139n, 149n, 151n, 157n, 163n, 167n, 173n, 179n, 181n, 191n, 193n, 197n, 199n];
  const knownComposites = [4n, 6n, 8n, 9n, 10n, 12n, 14n, 15n, 16n, 18n, 20n, 21n, 22n, 24n, 25n, 26n, 27n, 28n, 30n, 32n, 33n, 34n, 35n, 36n, 38n, 39n, 40n, 42n, 44n, 45n, 46n, 48n, 49n, 50n];
  
  let passedTests = 0;
  let totalTests = 0;
  const errors = [];
  
  // Test sui primi noti
  for (let p of knownPrimes) {
    totalTests++;
    if (isPrimeSecure(p)) {
      passedTests++;
    } else {
      errors.push(`ERRORE: ${p} dovrebbe essere primo ma l'engine dice composite`);
    }
  }
  
  // Test sui composti noti
  for (let c of knownComposites) {
    totalTests++;
    if (!isPrimeSecure(c)) {
      passedTests++;
    } else {
      errors.push(`ERRORE: ${c} dovrebbe essere composto ma l'engine dice primo`);
    }
  }
  
  // Test su numeri grandi noti
  const largePrimes = [1009n, 1013n, 1019n, 1021n, 1031n, 1033n, 1039n, 1049n, 1051n, 1061n];
  const largeComposites = [1001n, 1002n, 1003n, 1004n, 1005n, 1006n, 1007n, 1008n, 1010n, 1011n];
  
  for (let p of largePrimes) {
    totalTests++;
    if (isPrimeSecure(p)) {
      passedTests++;
    } else {
      errors.push(`ERRORE: ${p} dovrebbe essere primo ma l'engine dice composite`);
    }
  }
  
  for (let c of largeComposites) {
    totalTests++;
    if (!isPrimeSecure(c)) {
      passedTests++;
    } else {
      errors.push(`ERRORE: ${c} dovrebbe essere composto ma l'engine dice primo`);
    }
  }
  
  return {
    accuracy: (passedTests / totalTests * 100).toFixed(2),
    passed: passedTests,
    total: totalTests,
    errors: errors
  };
}

function testEngineAccuracy() {
  const r = document.getElementById("result");
  r.innerText = "üîç Testing engine accuracy on known primes and composites...";
  
  // Esegui il test dopo un breve delay per mostrare il messaggio
  setTimeout(() => {
    const testResult = runAccuracyTest();
    
    let output = `üéØ ENGINE ACCURACY TEST RESULTS\n`;
    output += `=================================\n`;
    output += `Accuracy: ${testResult.accuracy}%\n`;
    output += `Passed: ${testResult.passed}/${testResult.total} tests\n\n`;
    
    if (testResult.errors.length === 0) {
      output += `‚úÖ ALL TESTS PASSED!\n`;
      output += `The Binary Prime Engine is working with 100% accuracy.\n`;
      output += `All known primes and composites were correctly identified.`;
    } else {
      output += `‚ùå ERRORS FOUND:\n`;
      for (let error of testResult.errors) {
        output += `${error}\n`;
      }
    }
    
    r.innerText = output;
  }, 100);
}
 </script>
</body>
</html>