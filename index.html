
<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Binary Prime Engine</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #0f2027, #203a43, #2c5364);
      color: #fff;
    }
    header {
      background-color: #111;
      padding: 20px;
      text-align: center;
      font-size: 2em;
      font-weight: bold;
      color: #00d8ff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }
    .container {
      padding: 30px;
      max-width: 900px;
      margin: auto;
      background-color: #1e1e2f;
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 216, 255, 0.2);
    }
    .menu {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 30px;
    }
    .menu button {
      background: #00d8ff;
      color: #000;
      padding: 15px;
      font-size: 1.1em;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .menu button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 15px rgba(0,216,255,0.4);
    }
    input[type="number"] {
      width: 250px;
      padding: 12px;
      font-size: 1.2em;
      margin-bottom: 20px;
      border-radius: 10px;
      border: none;
      text-align: center;
    }
    .result {
      margin-top: 25px;
      padding: 15px;
      background-color: #292942;
      border-radius: 10px;
      font-size: 1.1em;
      white-space: pre-line;
    }
    canvas {
      display: block;
      margin: 30px auto 0 auto;
      border-radius: 12px;
      background: #fff;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
  <header>Binary Prime Engine</header>
  <div class="container">
    <input type="number" id="inputNumber" placeholder="Inserisci un numero">
    <div class="menu">
      <button onclick="checkPrime()">Verifica se primo</button>
      <button onclick="calculateGap()">Gap dₙ</button>
      <button onclick="findTwins()">Primi gemelli</button>
      <button onclick="findDoubleTwins()">Doppi gemelli</button>
      <button onclick="factorize()">Scomposizione</button>
      <!-- ...dentro la div .menu... -->
<button onclick="showBinaryPrimes()">Primi binari</button>
      <button onclick="generatePrimes()">Genera intervallo</button>
      <button onclick="drawSpiral3D()">Spirale 3D</button>
    </div>
    <div class="result" id="result"></div>
    <!-- ...dopo <div class="menu">... -->
    <div style="margin: 30px 0 10px 0; text-align:center;">
      <input type="number" id="spiralFrom" placeholder="Da (≥2)" min="2">
      <input type="number" id="spiralTo" placeholder="A (≤10000)" min="2">
      <button onclick="drawSpiral2D()">Spirale Logaritmica 2D</button>
    </div>
<!-- ...existing code... -->
    <canvas id="spiralCanvas" width="1200" height="1200"></canvas>
    <div id="spiral3dContainer" style="width:100%; height:500px; margin-top:30px;"></div>
  </div>

  <script>
const primeRules = {
  primorial: 210,
  moduloDivisors: [2, 3, 5, 7],
  binaryPatterns: ['10', '11', '100', '101', '111']
};
const smallPrimes = [2, 3, 5, 7];
function isPrimeBit(n) {
  if (n < 2) return false;
  const Pk = primeRules.primorial;
  const r = n % Pk;
  for (let d of primeRules.moduloDivisors) {
    if (r % d === 0) return false;
  }
  const binStr = n.toString(2);
  let binOk = false;
  for (let b of primeRules.binaryPatterns) {
    if (binStr.includes(b)) {
      binOk = true;
      break;
    }
  }
  if (!binOk) return false;
  return true;
}

function checkPrime() {
  const n = parseInt(document.getElementById("inputNumber").value);
  const r = document.getElementById("result");
  if (isNaN(n)) return r.innerText = "Inserisci un numero valido.";
  r.innerText = isPrimeBit(n) ? `${n} è un numero primo ✅` : `${n} non è primo ❌`;
}

function calculateGap() {
  const n = parseInt(document.getElementById("inputNumber").value);
  const r = document.getElementById("result");
  if (!isPrimeBit(n)) return r.innerText = `${n} non è primo`;
  let next = n + 1;
  while (!isPrimeBit(next)) next++;
  r.innerText = `Gap dₙ dopo ${n}: ${next - n}`;
}

function showBinaryPrimes() {
  const da = parseInt(prompt("Da (incluso):", "2"));
  const a = parseInt(prompt("A (incluso):", "100"));
  const r = document.getElementById("result");
  if (isNaN(da) || isNaN(a) || da > a) {
    r.innerText = "Intervallo non valido.";
    return;
  }
  if (a - da > 10000) {
    r.innerText = "Intervallo troppo grande (max 10.000 numeri).";
    return;
  }
  const B = ['10', '11', '100', '101', '111'];
  let out = `Primi binari tra ${da} e ${a}:\n\n`;
  // Aggiungi sempre i piccoli primi
  for (let p of smallPrimes) {
    if (p >= da && p <= a) {
      const binStr = p.toString(2);
      const patterns = B.filter(b => binStr.includes(b));
      out += `${p}: ${binStr}   [pattern: ${patterns.join(", ")}]\n`;
    }
  }
  for (let n = Math.max(da, 8); n <= a; n++) {
    if (isPrimeBit(n)) {
      const binStr = n.toString(2);
      const patterns = B.filter(b => binStr.includes(b));
      out += `${n}: ${binStr}   [pattern: ${patterns.join(", ")}]\n`;
    }
  }
  r.innerText = out;
}

function findTwins() {
  const da = parseInt(prompt("Da (incluso):"));
  const a = parseInt(prompt("A (incluso):"));
  const r = document.getElementById("result");
  if (isNaN(da) || isNaN(a) || da > a) return r.innerText = "Intervallo non valido.";
  if (a - da > 10000) return r.innerText = "Intervallo troppo grande (max 10.000 numeri).";
  const twins = [];
  // Gemelli tra piccoli primi
  for (let i = 0; i < smallPrimes.length - 1; i++) {
    const p1 = smallPrimes[i], p2 = smallPrimes[i + 1];
    if (p1 >= da && p2 <= a && p2 - p1 === 2) twins.push(`(${p1}, ${p2})`);
  }
  // Gemelli tra altri primi
  let last = null;
  for (let n = Math.max(da, 8); n <= a; n++) {
    if (isPrimeBit(n)) {
      if (last !== null && n - last === 2) twins.push(`(${last}, ${n})`);
      last = n;
    }
  }
  r.innerText = `Primi gemelli tra ${da} e ${a}:\n` + (twins.length ? twins.join(", ") : "Nessuna coppia trovata.");
}

function findDoubleTwins() {
  const da = parseInt(prompt("Da (incluso):", "2"));
  const a = parseInt(prompt("A (incluso):", "1000"));
  const r = document.getElementById("result");
  if (isNaN(da) || isNaN(a) || da > a) return r.innerText = "Intervallo non valido.";
  if (a - da > 10000) return r.innerText = "Intervallo troppo grande (max 10.000 numeri).";
  const doubles = [];
  // Doppi gemelli tra piccoli primi
  for (let i = 0; i < smallPrimes.length - 1; i++) {
    const p1 = smallPrimes[i], p2 = smallPrimes[i + 1];
    if (p1 >= da && p2 <= a && p2 - p1 === 4) doubles.push(`(${p1}, ${p2})`);
  }
  // Doppi gemelli tra altri primi
  let last = null;
  for (let n = Math.max(da, 8); n <= a; n++) {
    if (isPrimeBit(n)) {
      if (last !== null && n - last === 4) doubles.push(`(${last}, ${n})`);
      last = n;
    }
  }
  r.innerText = `Doppi gemelli (p, p+4) tra ${da} e ${a}:\n` + (doubles.length ? doubles.join(", ") : "Nessuna coppia trovata.");
}

function factorize() {
  let n = parseInt(document.getElementById("inputNumber").value);
  const r = document.getElementById("result");
  if (isNaN(n) || n < 2) return r.innerText = "Numero non valido.";
  const factors = [];
  let d = 2;
  while (n > 1) {
    while (n % d === 0) {
      factors.push(d);
      n /= d;
    }
    d++;
    if (d * d > n && n > 1) {
      factors.push(n);
      break;
    }
  }
  r.innerText = `Fattori primi: ` + factors.join(" × ");
}

function generatePrimes() {
  const da = parseInt(prompt("Da (incluso):"));
  const a = parseInt(prompt("A (incluso):"));
  const r = document.getElementById("result");
  if (isNaN(da) || isNaN(a) || da > a) return r.innerText = "Intervallo non valido.";
  if (a - da > 10000) return r.innerText = "Intervallo troppo grande (max 10.000 numeri).";
  const list = [];
  // Aggiungi sempre i piccoli primi se sono nell'intervallo
  for (let p of smallPrimes) {
    if (p >= da && p <= a) list.push(p);
  }
  for (let i = Math.max(da, 8); i <= a; i++) {
    if (isPrimeBit(i)) list.push(i);
  }
  r.innerText = `Primi tra ${da} e ${a}:\n` + list.join(", ");
}

function drawSpiral2D() {
  const canvas = document.getElementById("spiralCanvas");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let da = parseInt(document.getElementById("spiralFrom").value);
  let a = parseInt(document.getElementById("spiralTo").value);
  if (isNaN(da) || isNaN(a) || da < 2 || a < da || a-da > 10000) {
    alert("Intervallo non valido (da ≥2, a ≥ da, max 10.000 numeri)");
    return;
  }

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const scale = 45;
  const pointRadius = 2.2;
  const axisColor = "#888";
  const gridColor = "#eee";
  const primeColor = "#222";
  const title = "Spirale Logaritmica dei Numeri Primi";
  const subtitle = `Intervallo: ${da} - ${a}`;

  ctx.save();
  ctx.strokeStyle = gridColor;
  ctx.lineWidth = 1;
  for (let i = -6; i <= 6; i++) {
    ctx.beginPath();
    ctx.moveTo(centerX + i*scale*2, 0);
    ctx.lineTo(centerX + i*scale*2, canvas.height);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, centerY + i*scale*2);
    ctx.lineTo(canvas.width, centerY + i*scale*2);
    ctx.stroke();
  }
  ctx.restore();

  ctx.save();
  ctx.strokeStyle = axisColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, centerY);
  ctx.lineTo(canvas.width, centerY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(centerX, 0);
  ctx.lineTo(centerX, canvas.height);
  ctx.stroke();
  ctx.restore();

  ctx.save();
  ctx.font = "bold 22px Segoe UI";
  ctx.fillStyle = "#222";
  ctx.textAlign = "center";
  ctx.fillText(title, centerX, 40);
  ctx.font = "16px Segoe UI";
  ctx.fillText(subtitle, centerX, 65);
  ctx.restore();

  ctx.save();
  ctx.fillStyle = primeColor;
  ctx.save();
ctx.fillStyle = primeColor;
// Aggiungi sempre i piccoli primi se sono nell'intervallo
for (let p of smallPrimes) {
  if (p >= da && p <= a) {
    const r = Math.log(p) * scale;
    const theta = p * 0.25;
    const x = centerX + r * Math.cos(theta);
    const y = centerY + r * Math.sin(theta);
    ctx.beginPath();
    ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
    ctx.fill();
  }
}
// Poi disegna gli altri
for (let n = Math.max(da, 8); n <= a; n++) {
  if (isPrimeBit(n)) {
    const r = Math.log(n) * scale;
    const theta = n * 0.25;
    const x = centerX + r * Math.cos(theta);
    const y = centerY + r * Math.sin(theta);
    ctx.beginPath();
    ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
    ctx.fill();
  }
}
ctx.restore();
  for (let n = da; n <= a; n++) {
    if (isPrimeBit(n)) {
      const r = Math.log(n) * scale;
      const theta = n * 0.25;
      const x = centerX + r * Math.cos(theta);
      const y = centerY + r * Math.sin(theta);
      ctx.beginPath();
      ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
      ctx.fill();
    }
  }
  ctx.restore();

  ctx.save();
  ctx.font = "15px Segoe UI";
  ctx.fillStyle = primeColor;
  ctx.fillText("● Numeri primi", centerX + 180, 90);
  ctx.restore();
}

function drawSpiral3D() {
  const container = document.getElementById("spiral3dContainer");
  container.innerHTML = "";
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  const camera = new THREE.PerspectiveCamera(75, 1.8, 0.1, 1000);
  camera.position.z = 120;
  camera.position.y = 40;

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  const width = container.offsetWidth;
  const height = 500;
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  const geometry = new THREE.SphereGeometry(0.5, 12, 12);
  const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
  let angle = 0;
  let radius = 1;
  let heightStep = 0.6;

  for (let n = 2; n < 1000; n++) {
    if (isPrimeBit(n)) {
      const sphere = new THREE.Mesh(geometry, material);
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      const z = n * heightStep * 0.1;
      sphere.position.set(x, y, z);
      scene.add(sphere);
    }
    angle += 0.2;
    radius += 0.02;
  }

  const light = new THREE.PointLight(0xffffff, 1);
  light.position.set(50, 50, 100);
  scene.add(light);

  const animate = function () {
    requestAnimationFrame(animate);
    scene.rotation.z += 0.001;
    scene.rotation.x += 0.001;
    renderer.render(scene, camera);
  };
  animate();
}
</script>
</body>
</html>
